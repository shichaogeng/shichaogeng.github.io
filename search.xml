<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[FirewalldAndTelnet]]></title>
    <url>%2F2017%2F09%2F07%2FFirewalldAndTelnet%2F</url>
    <content type="text"><![CDATA[操作MySQL主从复制时候需要设定防火墙规则，决定还是总结记录一下。操作系统CentOs7 firewalld防火墙firewalld是centos7的一大特性，最大的好处有两个：支持动态更新，不用重启服务；第二个就是加入了防火墙的“zone”概念 firewalld的字符界面管理工具是 firewall-cmd firewalld默认配置文件有两个：/usr/lib/firewalld/ （系统配置）和 /etc/firewalld/ （用户配置） zone概念硬件防火墙默认一般有三个区，firewalld引入这一概念系统默认存在以下区域： drop：任何流入网络的包都被丢弃，不作出任何响应。只允许流出的网络连接。block：任何进入的网络连接都被拒绝，并返回 IPv4 的 icmp-host-prohibited 报文或者 IPv6 的 icmp6-adm-prohibited 报文。只允许由该系统初始化的网络连接。public：用以可以公开的部分。你认为网络中其他的计算机不可信并且可能伤害你的计算机。只允许选中的连接接入。external：用在路由器等启用伪装的外部网络。你认为网络中其他的计算机不可信并且可能伤害你的计算机。只允许选中的连接接入。dmz：用以允许隔离区（dmz）中的电脑有限地被外界网络访问。只接受被选中的连接。work：用在工作网络。你信任网络中的大多数计算机不会影响你的计算机。只接受被选中的连接。home：用在家庭网络。你信任网络中的大多数计算机不会影响你的计算机。只接受被选中的连接。internal：用在内部网络。你信任网络中的大多数计算机不会影响你的计算机。只接受被选中的连接。 安装、运行、停止、禁用、重启firewalld 安装 1yum -y install firewalld firewall-config 启动 1systemctl start firewalld 查看状态 1systemctl status firewalld 或者 firewall-cmd --state 停止] 1systemctl disable firewalld 禁用 1systemctl stop firewalld 更新防火墙规则(不会重启服务) 1firewall-cmd --reload 更新防火墙规则（会重启服务） 1firewall-cmd --complete-reload 配置firewalld 查看版本 1firewall-cmd --version 查看帮助 1firewall-cmd --help 查看区域信息 1firewall-cmd --get-active-zones 查询默认区域 1firewall-cmd --get-default-zone 设置默认区域 1firewall-cmd --set-default-zone=public 查看所有打开的端口 1firewall-cmd --zone=dmz --list-ports 查询端口是否启用 1firewall-cmd [--zone=&lt;zone&gt;] --query-port=&lt;port&gt;[-&lt;port&gt;]/&lt;protocol&gt; 添加指定端口 12firewall-cmd --zone=&lt;zone&gt; --add-port=&lt;port&gt;[-&lt;port&gt;]/&lt;protocol&gt; [--timeout=&lt;seconds&gt;]# 要使定义的协议永久生效，需要加一句--permanent，--zone不写则使用默认区域 移除允许的端口： 1firewall-cmd [--zone=&lt;zone&gt;] --remove-port=&lt;port&gt;[-&lt;port&gt;]/&lt;protocol&gt; 参考资料 官方文档 wiki 安装telnet 先检查CentOS7.0是否已经安装以下两个安装包:telnet-server、xinetd。 12[root@localhost sysconfig]# rpm -qa telnet-server[root@localhost sysconfig]# rpm -qa xinetd 如果没有安装，则先安装。安装命令 1234567891011121314151617[root@localhost ~]# yum list | grep telnettelnet.x86_64 1:0.17-60.el7 base telnet-server.x86_64 1:0.17-60.el7 base [root@localhost ~]# yum -y install telnet-server.x86_64[root@localhost ~]# yum -y install telnet.x86_64[root@localhost ~]# yum list |grep xinetdxinetd.x86_64 2:2.3.15-13.el7 base [root@localhost ~]# yum -y install xinetd.x86_64``` 1. 安装完成后，将xinetd服务加入开机自启动```bash[root@localhost ~]# systemctl enable xinetd.service 最后，启动以上两个服务即可： 12[root@localhost ~]# systemctl start telnet.socket[root@localhost ~]# systemctl start xinetd 将telnet服务加入开机自启动 12[root@localhost ~]# systemctl enable telnet.socketCreated symlink from /etc/systemd/system/sockets.target.wants/telnet.socket to /usr/lib/systemd/system/telnet.socket. 使用的时候，用telnet测试下端口是否可以访问 1234567891011121314151617181920[root@localhost ~]# ping 192.168.25.143PING 192.168.25.143 (192.168.25.143) 56(84) bytes of data.64 bytes from 192.168.25.143: icmp_seq=1 ttl=64 time=0.529 ms64 bytes from 192.168.25.143: icmp_seq=2 ttl=64 time=0.473 ms64 bytes from 192.168.25.143: icmp_seq=3 ttl=64 time=0.473 ms64 bytes from 192.168.25.143: icmp_seq=4 ttl=64 time=0.496 ms^C--- 192.168.25.143 ping statistics ---4 packets transmitted, 4 received, 0% packet loss, time 3001msrtt min/avg/max/mdev = 0.473/0.492/0.529/0.035 ms# 网络连接成功，下面测试端口[root@localhost ~]# telnet 192.168.25.143 3306Trying 192.168.25.143...Connected to 192.168.25.143.Escape character is '^]'.N5.7.14-log gBI8)"ÿ󿾂uc49BQ,emysql_native_password123456!#08S01Got packets out of orderConnection closed by foreign host.]]></content>
      <categories>
        <category>Linux设置</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL优化（一）--- MySQL主从复制]]></title>
    <url>%2F2017%2F08%2F30%2FMySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[MySQL Replication是MySQL官方提供的主从同步方案，用于将一个MySQL实例的数据，同步到另一个实例中。Replication为保证数据安全做了重要保证，也是现在运用最广的MySQL容灾方案。Replication用两个或以上的实例搭建MySQL主从复制集群，提供单点写入，多点读取的服务，实现了读的scale out。 主从复制的原理MySQL内建的复制功能是构建大型，高性能应用程序的基础。将MySQL的数据分布到多个系统上去，这种分布的机制，是通过将MySQL的某一台主机的数据复制到其它主机（slaves）上，并重新执行一遍来实现的。复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。主服务器将更新写入二进制日志文件，并维护文件的一个索引以跟踪日志循环。这些日志可以记录发送到从服务器的更新。当一个从服务器连接主服务器时，它通知主服务器从服务器在日志中读取的最后一次成功更新的位置。从服务器接收从那时起发生的任何更新，然后封锁并等待主服务器通知新的更新。 MySQL主从复制相关有3个线程 slave上的I/O线程：向master请求数据 master上的Binlog Dump线程：读取binlog事件并把数据发送给slave上的I/O线程 slave上的SQL线程：读取中继日志并执行，更新数据库 下图描述了复制的过程： 从上图分析的主从复制的3个步骤： master将改变记录到二进制日志(binary log)中（这些记录叫做二进制日志事件，binary log events）。 在每个事务更新数据完成之前，master在二日志记录这些改变。MySQL将事务串行的写入二进制日志，即使事务中的语句都是交叉执行的。在事件写入二进制日志完成后，master通知存储引擎提交事务。 slave将master的binary log events拷贝到它的中继日志(relay log)。 首先，slave开始一个工作线程——I/O线程。I/O线程在master上打开一个普通的连接，然后开始binlog dump process。Binlog dump process从master的二进制日志中读取事件，如果已经跟上master，它会睡眠并等待master产生新的事件。I/O线程将这些事件写入中继日志。 slave重做中继日志中的事件，将改变反映它自己的数据。该过程的第一部分就是master记录二进制日志。 SQL slave thread（SQL从线程）处理该过程的最后一步。SQL线程从中继日志读取事件，并重放其中的事件而更新slave的数据，使其与master中的数据一致。只要该线程与I/O线程保持一致，中继日志通常会位于OS的缓存中，所以中继日志的开销很小。 复制过程有一个很重要的限制——复制在slave上是串行化的，也就是说master上的并行更新操作不能在slave上并行操作。 主从复制的配置准备环境有两台MySQL数据库服务器master和slave，master为主服务器，slave为从服务器，初始状态时，通过MySQL备份机制令master和slave中的数据信息相同，当Master中的数据发生变化时，slave也跟着发生相应的变化，使得master和slave的数据信息同步，达到备份的目的。要点：负责在主、从服务器传输各种修改动作的媒介是主服务器的二进制变更日志，这个日志记载着需要传输给从服务器的各种修改动作。因此，主服务器必须激活二进制日志功能。从服务器必须具备足以让它连接主服务器并请求主服务器把二进制变更日志传输给它的权限。 环境：master和slave的MySQL数据库版本同为5.7.14操作系统：CentOs 3.10.0-514.el7.x86_64IP地址：master=’192.168.25.143’,slave=’192.168.25.138’ 首先保证两台机器网络上互通然后对端口进行防火墙设置。（防火墙设置及Telnet安装） 123456789101112131415161718192021# 开启端口[root@localhost ~]# firewall-cmd --zone=public --add-port=3306/tcp --permanentsuccess# 不需重启服务重新加载防火墙规则[root@localhost ~]# firewall-cmd --reloadsuccess# 查询端口是否启用：[root@localhost ~]# firewall-cmd --zone=public --query-port=3306/tcpyes# 使用telnet测试端口链接[root@localhost ~]# telnet 192.168.25.143 3306Trying 192.168.25.143...Connected to 192.168.25.143.Escape character is '^]'.N5.7.14-log gBI8)"ÿ󿾂uc49BQ,emysql_native_password123456!#08S01Got packets out of orderConnection closed by foreign host. 真实场景肯定是已经有很多历史数据在老数据库中，而且服务器正在运行并对外提供服务，我们模拟下这个环境。在master机数据库上创建库表。 123456789101112mysql&gt; create database db1;Query OK, 1 row affected (0.00 sec)mysql&gt; use db1;Database changedmysql&gt; create table t1(id int);Query OK, 0 rows affected (0.01 sec)mysql&gt; insert into t1 values(1),(2),(3);Query OK, 3 rows affected (0.00 sec)Records: 3 Duplicates: 0 Warnings: 0 配置master先要复制master上已有的数据到slave上，而且master服务不能停，这就需要基于二进制日志来操作。在master上开启二进制日志。包括打开二进制日志，指定唯一的servr-id。 修改my.cnf,添加如下配置（设置服务id，开启二进制日志） 12server-id=1log-bin=/var/lib/mysql/mysql-bin 重启服务 12[root@localhost ~]# service mysqld restart;Redirecting to /bin/systemctl restart mysqld.service 查看master二进制日志状态 12345678mysql&gt; show master status;+------------------+----------+--------------+--------------- ---+-------------------+| File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |+------------------+----------+--------------+--------------- ---+-------------------+| mysql-bin.000001 | 154 | | | |+------------------+----------+--------------+--------------- ---+-------------------+1 row in set (0.00 sec)# 注意，position位置就是二进制日志复制的起点。 在/var/lib/mysql文件夹下生成如下二进制日志文件 1-rw-r-----. 1 mysql mysql 154 8月 30 22:07 mysql-bin.000001 拷贝数据关停master服务器，将master中的数据拷贝到slave服务器中，使得master和slave中的数据同步。 备份 1[root@localhost charsets]# mysqldump -uroot -p --single-transaction --master-data=2 --triggers --routines --all-databases &gt; ~/abc.sql 生成备份文件如下 1-rw-r--r--. 1 root root 767934 8月 30 23:01 abc.sql 查看此文件，注意看MASTER_LOG_POS 12-- CHANGE MASTER TO MASTER_LOG_FILE='mysql-bin.000004', MASTER_LOG_POS=154;# 它标记了从154位置之前的数据已经备份到abc.sql中，以后的数据要从154开始，我们会在slave里用到。 在slave上操作，把abc.sql从master远程拷贝到salve 123456789[root@localhost ~]# scp root@192.168.25.143:/root/abc.sql ~The authenticity of host '192.168.25.143 (192.168.25.143)' can't be established.ECDSA key fingerprint is 1f:eb:16:4e:2e:34:e1:7f:79:a4:b2:e7:51:b7:83:9d.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added '192.168.25.143' (ECDSA) to the list of known hosts.root@192.168.25.143's password: Permission denied, please try again.root@192.168.25.143's password: abc.sql 100% 750KB 749.9KB/s 00:00 在slave上执行abc.sql（重定向） 12[root@localhost ~]# mysql -uroot -p &lt; ~/abc.sqlEnter password: 查看slave数据库，发现导入成功 1234567891011mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || db1 || mysql || performance_schema || sys |+--------------------+5 rows in set (0.00 sec) 这时备份时点的数据已经拷贝到从服务器上了 创建复制帐号在master的数据库中建立一个备份帐户：每个slave使用标准的MySQL用户名和密码连接master。进行复制操作的用户会授予REPLICATION SLAVE权限。用户名的密码都会存储在文本文件master.info中。 创建授权用户 123456789? grant# 上面是查看授权语法mysql&gt; grant replication slave on *.* to 'slave'@'192.168.25.138' identified by 'Gengsc_123';Query OK, 0 rows affected, 1 warning (0.00 sec)# 注意上面的密码因为密码策略的原因要大小写字母特殊符号数字同时具备（我记得是这样）mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec) 查看是否成功 12345mysql&gt; select * from mysql.user where host = '192.168.25.138'\G;*************************** 1. row *************************** Host: 192.168.25.138 User: slave Repl_slave_priv: Y 执行完授权后，我们来查看下master状态 12345678mysql&gt; show master status\G;*************************** 1. row *************************** File: mysql-bin.000005 Position: 154 Binlog_Do_DB: Binlog_Ignore_DB: Executed_Gtid_Set: 1 row in set (0.00 sec) 配置slave配置在下面，其中，server_id：是必须的，而且唯一。slave：没有必要开启二进制日志，但是在一些情况下，必须设置，例如，如果slave为其他slave的master，必须设置log-bin。在这里，我们开启二进制日志。relay_log：配置中继日志。log_slave_updates：表示slave将复制事件写进自己的二进制日志。有些人开启了slave的二进制日志，却没有设置log_slave_updates，这是一种错误的配置。原因：从库开启log-bin参数，如果直接往从库写数据，是可以记录log-bin日志的，但是从库通过I0线程读取主库二进制日志文件，然后通过SQL线程写入的数据，是不会记录binlog日志的。也就是说从库从主库上复制的数据，是不写入从库的binlog日志的。所以从库做为其他从库的主库时需要在配置文件中添加log-slave-updates参数。 编辑my.cnf 1234server-id=2log-bin=/var/lib/mysql/mysql-binrelay_log=/var/lib/mysql/mysql-relay-binlog_slave_updates=1 重启MySQL服务 12[root@localhost ~]# service mysqld restart;Redirecting to /bin/systemctl restart mysqld.service 启动slave接下来就是让slave连接master，并开始重做master二进制日志中的事件。使用CHANGE MASTER TO语句不需要停止服务器。如下： 如果之前这台slave已经做过从机，先停止主从复制 1stop slave; 如果之前这台slave已经做过从机，先清空之前的relay-log 1reset slave; 为slave指定master 123456mysql&gt; change master to master_host='192.168.25.143',-&gt; master_user='slave',-&gt; master_password='Gengsc_123',-&gt; master_log_file='mysql-bin.000004',-&gt; master_log_pos=154;Query OK, 0 rows affected, 2 warnings (0.03 sec) 启动Slave开始复制 12mysql&gt; start slave;Query OK, 0 rows affected (0.01 sec) 检查主从同步状态，主要查看io线程和sql线程状态(Slave_IO_Running和Slave_SQL_Running) 123456789101112131415mysql&gt; show slave status\G*************************** 1. row ***************************Slave_IO_State: Waiting for master to send eventMaster_Host: 192.168.25.143Master_User: slaveMaster_Port: 3306Connect_Retry: 60Master_Log_File: mysql-bin.000004Read_Master_Log_Pos: 2167Relay_Log_File: localhost-relay-bin.000002Relay_Log_Pos: 2333Relay_Master_Log_File: mysql-bin.000004Slave_IO_Running: YesSlave_SQL_Running: YesReplicate_Do_DB: 常见错误：Slave_IO_Running=NO：检查change master语句中ip log_file log_pos等所有参数Slave_SQL_Running=NO：因为主从同步需要创建用户，查看当前登录用户是否有此权限 查看线程你可已查看master和slave上的线程状态 在master上，你可以看见slave的io线程创建的链接（dump线程） 12345678910mysql&gt; show processlist\G;*************************** 1. row *************************** Id: 4 User: slave Host: 192.168.25.138:53396 db: NULLCommand: Binlog Dump Time: 172 State: Master has sent all binlog to slave; waiting for more updates Info: NULL 在slave上，你可以看到io线程状态和sql线程状态 12345678910111213141516171819mysql&gt; show processlist\G;*************************** 1. row *************************** Id: 4 User: system user Host: db: NULLCommand: Connect Time: 599068 State: Waiting for master to send event Info: NULL*************************** 2. row *************************** Id: 5 User: system user Host: db: NULLCommand: Connect Time: 598967 State: Slave has read all relay log; waiting for more updates Info: NULL 验证主从同步 在master中操作 123456789101112mysql&gt; create database db2;Query OK, 1 row affected (0.01 sec)mysql&gt; use db2;Database changedmysql&gt; create table user(id int,name varchar(20));Query OK, 0 rows affected (0.03 sec)mysql&gt; insert into user values (1,'张三'),(2,'李四');Query OK, 2 rows affected (0.09 sec)Records: 2 Duplicates: 0 Warnings: 0 在slave中查看 1234567891011121314151617181920212223242526mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || db1 || db2 || mysql || performance_schema || sys |+--------------------+6 rows in set (0.00 sec)mysql&gt; use db2;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; select * from user;+------+--------+| id | name |+------+--------+| 1 | 张三 || 2 | 李四 |+------+--------+2 rows in set (0.00 sec) 大功告成。]]></content>
      <categories>
        <category>MySQL优化</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL优化（一）--- MySQL锁机制]]></title>
    <url>%2F2017%2F08%2F29%2FMySQL%E9%94%81%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[为了保证数据的一致完整性，任何一个数据库都存在锁定机制。锁定机制的优劣直接响应到一个数据库系统的并发处理能力和性能，所以锁定机制的实现也就成为了各种数据库的核心技术之一。本章将对MySQL中两种使用最为频繁的存储引擎MyISAM和Innodb各自的锁定机制进行较为详细的分析。 理论基础总的来说，划分锁类型要依赖两种标准。按照对数据操作的类型分：读锁，写锁。按照数据操作的粒度：表锁，行锁，页锁（本文不作介绍）。 读锁也称为共享锁。 共享锁的代号是S，是Share的缩写。针对同一资源，多个并发读操作可以并行执行，并且互不影响,不能写。 写锁也称排它锁。排它锁的代号是X，是eXclusive的缩写。当前线程写数据的时候，会阻塞其它线程来读取或者写数据。 表锁就是锁住整个表，主要在myisam表存储引擎中出现，myisam默认表锁。表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免死锁问题。当然，锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并发度较低。 行锁锁定单独的某个表中的某一行记录，主要用于innodb存储引擎，innodb默认行锁。行级锁是目前各大数据库管理软件所实现的锁定颗粒度最小的,所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。 但是由于锁定资源的颗粒度很小，所以每次获取锁和释放锁消耗的资源也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。 实践测试表结构及数据12345678910111213141516171819/* 表锁案例*/create table lock_one( id int primary key auto_increment, col int)engine=myisam;insert into lock_one(col) values (1);insert into lock_one(col) values (2);insert into lock_one(col) values (3);/* 行锁案例*/create table lock_two( id int, col int)engine=innodb;insert into lock_two(id,col) values (1,1);insert into lock_two(id,col) values (2,2);insert into lock_two(id,col) values (3,3); 测试表锁语法： 123456789101112# 手动增加表锁：lock table 表名 [read|write]，表名 [read|write]…# 查看锁状态show open tables; # 解开所有锁unlock tables;# 表锁的一些状态查询：show status like 'table_lock%';说明:Table_locks_immediate：表示可以立即获取锁的查询次数，每获取一次锁就增加Table_locks_waited：锁等待的次数 测试全表读锁 开两个会话session1和session2 在session1中锁定lock_one表 MySQL&gt; lock table lock_one read; Query OK, 0 rows affected (0.00 sec) 在session1中对lock_one执行查询，成功 MySQL&gt; select * from lock_one\G;*************************** 1. row ***************************id: 1col: 1*************************** 2. row ***************************id: 2col: 2*************************** 3. row ***************************id: 3col: 33 rows in set (0.00 sec) 在session1中对lock_one执行修改，报错 MySQL&gt; update lock_one set col = 11 where id = 1;ERROR 1099 (HY000): Table ‘lock_one’ was locked with a READ lock and can’t be updated 在session1中对lock_two执行查询，报错 MySQL&gt; update lock_two set col = 11 where id = 1;ERROR 1100 (HY000): Table ‘lock_two’ was not locked with LOCK TABLES 在session1中对lock_two执行修改，报错 MySQL&gt; update lock_two set col = 11 where id = 1;ERROR 1100 (HY000): Table ‘lock_two’ was not locked with LOCK TABLES 在session2中对lock_one执行查询，成功 MySQL&gt; select * from lock_one\G;*************************** 1. row ***************************id: 1col: 1*************************** 2. row ***************************id: 2col: 2*************************** 3. row ***************************id: 3col: 33 rows in set (0.00 sec) 在session2中对lock_one执行修改，阻塞。 MySQL&gt; update lock_one set col = 22 where id = 2; 在session1中解锁 MySQL&gt; unlock tables;Query OK, 0 rows affected (0.00 sec) session2中阻塞更新操作执行 MySQL&gt; update lock_one set col = 22 where id = 2;Query OK, 1 row affected (17.71 sec)Rows matched: 1 Changed: 1 Warnings: 0 在session2中对lock_two执行查询，成功 MySQL&gt; select * from lock_two\G;*************************** 1. row ***************************id: 1col: 1*************************** 2. row ***************************id: 2col: 2*************************** 3. row ***************************id: 3col: 33 rows in set (0.01 sec) 在session2中对lock_two执行修改，成功 MySQL&gt; update lock_two set col = 2;Query OK, 2 rows affected (0.01 sec)Rows matched: 3 Changed: 2 Warnings: 0 据以上测试，结果如下： session1 session2 发送锁表语句lock table t1 read; 连接 可以查询当前锁定的表t1 可以查询t1 更新t1表，报错 更新t1表，阻塞 查询其他表，报错 可以查询其他表 更新其他表，报错 可以查询其他表 执行unlock tables 执行等待的更新操作 分析：读锁是共享锁。在全表上添加读锁时，本线程被锁定，只能进行被锁定表的读操作。其他线程可以对共享表进行读操作，但是要等待锁释放才能进行写操作。 测试全表写锁 开两个会话session1和session2 在session1中锁定lock_one表 MySQL&gt; lock table lock_one write;Query OK, 0 rows affected (0.00 sec) 在session1中对lock_one执行查询，成功 MySQL&gt; select * from lock_one\G*************************** 1. row ***************************id: 1col: 2*************************** 2. row ***************************id: 2col: 22*************************** 3. row ***************************id: 3col: 23 rows in set (0.00 sec) 在session1中对lock_one执行修改，成功 MySQL&gt; update lock_one set col = 3;Query OK, 3 rows affected (0.00 sec)Rows matched: 3 Changed: 3 Warnings: 0 在session1中对lock_two执行查询，报错 MySQL&gt; select * from lock_two;ERROR 1100 (HY000): Table ‘lock_two’ was not locked with LOCK TABLES 在session1中对lock_two执行修改，报错 MySQL&gt; update lock_two set col = 2;ERROR 1100 (HY000): Table ‘lock_two’ was not locked with LOCK TABLES 在session2中对lock_one执行查询，阻塞 MySQL&gt; select * from lock_one\G; 在session1中执行 MySQL&gt; unlock tables;Query OK, 0 rows affected (0.00 sec) session2中查询执行 MySQL&gt; select * from lock_one\G;*************************** 1. row ***************************id: 1col: 2*************************** 2. row ***************************id: 2col: 2*************************** 3. row ***************************id: 3col: 23 rows in set (0.00 sec) 在session2中对lock_one执行修改，阻塞。 MySQL&gt; update lock_one set col = 22 where id = 2; 在session1中解锁 MySQL&gt; unlock tables;Query OK, 0 rows affected (0.00 sec) session2中阻塞更新操作执行 MySQL&gt; update lock_one set col = 22 where id = 2;Query OK, 1 row affected (17.71 sec)Rows matched: 1 Changed: 1 Warnings: 0 在session2中对lock_two执行查询，成功 MySQL&gt; select * from lock_two\G;*************************** 1. row ***************************id: 1col: 1*************************** 2. row ***************************id: 2col: 2*************************** 3. row ***************************id: 3col: 33 rows in set (0.01 sec) 在session2中对lock_two执行修改，成功 MySQL&gt; update lock_two set col = 2;Query OK, 2 rows affected (0.01 sec)Rows matched: 3 Changed: 2 Warnings: 0 据以上测试，结果如下： session1 session2 发送锁表语句lock table t1 write; 连接 可以查询当前锁定的表t1 查询t1,阻塞 可以更新t1表 更新t1表，阻塞 查询其他表，报错 可以查询其他表 更新其他表，报错 可以查询其他表 执行unlock tables 执行等待的操作 分析：写锁是排他锁。在全表上添加写锁时，本线程被锁定，只能进行被锁定表的读写操作。其他线程等待本线程释放排他锁，才能进行读写操作。 MYISAM存储引擎中锁的特点执行select语句的时候，会自动给涉及的表加上读锁，在执行更新操作时，会自动给表加上写锁。 myisam存储引擎比较适合作为以查询为主的表存储引擎，不适合写为主的表存储引擎，因为加写锁后，是锁住整个表，其他用户线程不能做任何操作，这样会导致大量用户线程堵塞的情况。 测试行锁语法12345678910111213141516171819202122232425262728293031323334# 隔离级别show variables like '%iso%';# 查看自动提交参数show variables like '%autocommit%';# 关闭自动提交set autocommit = 0;# 手动锁一行记录begin; select \* from lock_two where id=2 for update；# 查看行锁的信息show status like '%innodb_row_lock%'\G;输出结果：*************************** 1. row ***************************Variable_name: Innodb_row_lock_current_waits Value: 0*************************** 2. row ***************************Variable_name: Innodb_row_lock_time Value: 147166*************************** 3. row ***************************Variable_name: Innodb_row_lock_time_avg Value: 21023*************************** 4. row ***************************Variable_name: Innodb_row_lock_time_max Value: 51044*************************** 5. row ***************************Variable_name: Innodb_row_lock_waits Value: 75 rows in set (0.00 sec)说明：Innodb_row_lock_current_waits ：当前正在等待的数量Innodb_row_lock_time: 从启动到现在锁定的总时长，单位是msInnodb_row_lock_time_avg :锁等待的平均时长Innodb_row_lock_time_max：等待锁时间最长的一个时间Innodb_row_lock_waits：总共的等待次数 开始测试 开启两个会话session1、session2 在两个会话中设置自动提交为手动提交 MySQL&gt; set autocommit=0;Query OK, 0 rows affected (0.00 sec) 在session1中执行update，没有提交事物 MySQL&gt; update lock_two set col = 2 where id = 2;Query OK, 0 rows affected (0.00 sec)Rows matched: 1 Changed: 0 Warnings: 0 在session2中update同一行记录，发生阻塞 MySQL&gt; update lock_two set col = 2 where id = 2; 提交session1和session2中的事物 MySQL&gt; commit; Query OK, 0 rows affected (0.00 sec) 分析：InnoDB自动加行级锁，修改时改行记录已被锁定，其他会话不能修改。 在session1中执行update,没有提交事物 MySQL&gt; MySQL&gt; update lock_two set col = 3 where id = 3;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0 在session2中执行update，操作非同行记录，发生阻塞 MySQL&gt; update lock_two set col = 22 where id = 2; 提交session1和session2中的事物 MySQL&gt; commit;Query OK, 0 rows affected (0.00 sec) 为嘛啊，为嘛啊，说好的行锁呢。分析：实际上，因为MySQL不确定哪行记录被修改，会在全表的范围上加上读锁，然后其他会话就不能更新该表记录。 在lock_two上建立索引 MySQL&gt; create index idx_id on lock_two(id);Query OK, 0 rows affected (0.03 sec)Records: 0 Duplicates: 0 Warnings: 0 执行第4步的操作： 在session1中执行update,没有提交事物 MySQL&gt;update lock_two set col = 3 where id = 3;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0 在session2中执行update，操作非同行记录，操作成功 MySQL&gt; MySQL&gt; update lock_two set col = 22 where id = 2;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0 提交session1和session2中的事物 MySQL&gt; commit;Query OK, 0 rows affected (0.00 sec) 为嘛啊，为嘛啊，又和说好的不一样。分析：大概，也许，因为MySQL能通过索引快速的锁定被修改的行，所以只会在被操作范围的记录上加上行锁，然后其他会话就能更新非此范围记录。 间隙锁 在session1中修改范围记录，不提交 MySQL&gt; update lock_two set col = 1 where id &gt; 2 and id &lt; 8;Query OK, 2 rows affected (0.00 sec)Rows matched: 2 Changed: 2 Warnings: 0 在session2中插入id在session1修改where范围的记录，发生阻塞 MySQL&gt; insert into lock_two values(4,4);ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction 分析：在范围查找的情况下，innodb会给范围条件中的数据加上锁，无论数据是否是否真实存在。建议：在innodb中，因为有间隙锁的存在，最好在where中少使用这种范围查找 测试结果结论：如果没有用上索引，行锁变成表锁原因：在不使用索引的情况下，更新表要全表扫描查询定位更新记录的位置，所以会在表上加全表读锁。在有索引的情况下，会走索引查询记录，只使用行锁即可。 InnoDB存储引擎中锁的特点InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。支持事务，开销大，加锁慢；会出现死锁；锁的粒度小，并发情况下，产生锁等待的概率比较低，所以支持的并发数比较高]]></content>
      <categories>
        <category>MySQL优化</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL优化（二）--- MySQL库表设计]]></title>
    <url>%2F2017%2F08%2F28%2FMySQL%E5%BA%93%E8%A1%A8%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[MySQL 数据库是被广泛应用的关系型数据库，其体积小、支持多处理器、开源并免费的特性使其在Internet中小型网站中的使用率尤其高。在使用 MySQL 的过程中不规范的SQL编写、非最优的策略选择都可能导致系统性能甚至功能上的缺陷。本文主要对数据库库表设计上的一些规范做出总结，希望能有助于各位同行解决工作中的相关问题。 作为软件工程师对数据库的定位以下对软件工程师在数据库方面的主要工作做出总结： 业务驱动表的设计 如何写出sql，既满足业务，又高效 从数据库角度会分析抓取慢sql，并优化 掌握复杂业务或者大数据表的设计思路 MySQL逻辑架构了解MySQL的第一步，就要先了解MySQL的功能组件和执行流程。如下就是MySQL逻辑架构图： 从架构图分析，MySQL的执行流程： 库表设计MySQL存储引擎的选择在 MySQL 5.1 中，引入了新的插件式存储引擎体系结构，允许将存储引擎加载到正在运新的MySQL服务器中。使用MySQL插件式存储引擎体系结构，允许数据库专业人员或者设计库表的软件开发人员为特定的应用需求选择专门的存储引擎，完全不需要管理任何特殊的应用编码要求，也无需考虑所有的底层实施细节。因此，尽管不同的存储引擎具有不同的能力，应用程序是与之分离的。此外，使用者可以在服务器、数据库和表格三个层级中存储引擎，提供了极大的灵活性。 MySQL 常用的存储引擎包括MYISAM、Innodb和Memory。还有其他种类，这里不做赘述。那么从哪些方面来评判选择搜索引擎呢？ 是否支持事务 :ACID 检索和添加速度 锁机制 缓存 是否支持全文索引 是否支持外键 空间占用 其中各自的特点对比如下： 评判标准 MYISAM Innodb Memory 事物 不支持 支持 锁 全表锁 行级锁 全表锁 缓存 缓存索引，不缓存数据 缓存索引和数据 检索、添加速度 有较高 MYISAM 速度快 全文索引 支持 不支持 外键 不支持 支持 占用空间 较小 MYISAM 的 2.5 和数据量成正比的内存空间，且重启丢失 关注 性能 事物 性能 注：MYISAM : 并发性能差，MySQL 5.5 及以下仅 MYISAM 支持全文索引，不支持事务。在表有读取查询的同时，支持往表中插入新纪录Innodb：，并发能力相对强不支持全文索引（5.6开始支持），支持事务。在innodb存储引擎中应用比较多，支持事务，开销大，加锁慢；会出现死锁；锁的粒度小，并发情况下，产生锁等待的概率比较低，所以支持的并发数比较高 总体来讲，MyISAM适合SELECT密集型的表，而InnoDB适合INSERT和UPDATE密集型的表 基于以上特性，建议绝大部份都设置为innodb引擎，特殊的业务再考虑选用 MYISAM 或 Memory ，如全文索引支持或极高的执行效率等。 范式化设计1NF：原子性，列不可分。每一列都是不可分割的基本数据项2NF：1NF的基础上面，非主属性完全依赖于主关键字3NF：属性不依赖于其它非主属性 , 消除传递依赖 。一个非关键属性不应该依赖一个关键属性 使用范式会有哪些优缺点？ 优点： 避免数据冗余 减少数据的空间 减轻维护数据完整性的麻烦 范式设计的表通常比较小，可以更好的利用内存的优势，提高我们的检索速度 缺点： 经过范式设计出来的表，会很多，越严格来遵循，表就越多 多表关联会慢，可能会导致索引失效 范式越高，对操作性能可能就越低 简单来说就是单表快，多表慢，这里就可以运用到反范式化设计 反范式化设计不符合3NF的设计就是反范式，适当的增加冗余减少表的关联优化查询效率，以空间换时间，在NOSQL中大量运用 运用场景：检索性能要求高对冗余字段很少做更新操作]]></content>
      <categories>
        <category>MySQL优化</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL优化（一）--- MySQL环境准备]]></title>
    <url>%2F2017%2F08%2F28%2FMySQL%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[最近系统看了下MySQL，决定写系列文章做个总结，为自己做个梳理，也为以后有新的idea或者收获都有个修正和添加记录的地方。先说一点，实际上网上的资料和本文在MySQL官网上都有，英语好的推荐直接阅读官方文档，英语不好先学好英语去阅读官方文档。 开始搭建Linux环境首先，需要linux环境，本文环境 Linux CentOs 3.10.0-514.el7.x86_64 MySQL下载然后，下载MySQL,本文环境 Mysql 5.7.14-1.el7.x86_64 进入官网下载页面，进入如下页面，选择操作系统并点击下载 MySQL安装 root用户登录 在root目录下面新建env目录，上传安装包到env目录，并创建mysql-install.sh脚本 [root@localhost env]# pwd &amp;&amp; ll /root/env 总用量 556004 -rw-r–r–. 1 root root 569344000 8月 25 19:49 mysql-5.7.14-1.el7.x86_64.rpm-bundle.tar -rw-r–r–. 1 root root 465 8月 25 19:48 mysql-install.sh 其中mysql-install.sh 中的命令为（注意替换为自己数据库版本）： 123456789101112#!/bin/bashmkdir mysqltar -xvf mysql-5.7.14-1.el7.x86_64.rpm-bundle.tar -C ./mysqlcd mysql &amp;&amp; yum remove mysql-libs -yrpm -ivh mysql-community-common-5.7.14-1.el7.x86_64.rpmrpm -ivh mysql-community-libs-5.7.14-1.el7.x86_64.rpm rpm -ivh mysql-community-client-5.7.14-1.el7.x86_64.rpm rpm -ivh mysql-community-server-5.7.14-1.el7.x86_64.rpmrpm -ivh mysql-community-devel-5.7.14-1.el7.x86_64.rpmcd ../#cp binary_log_types.h /usr/include/mysql/rm -rf mysql 运行完毕之后目录结构为： [root@localhost env]# pwd &amp;&amp; ll /root/env 总用量 556004 -rw-r–r–. 1 root root 569344000 8月 25 19:49 mysql-5.7.14-1.el7.x86_64.rpm-bundle.tar -rw-r–r–. 1 root root 465 8月 25 19:48 mysql-install.sh 安装好之后，按如下配置： 编辑MySQL配置文件my.cnf vi /etc/my.cnf #编辑文件，找到[mysqld]，在下面添加一行skip-grant-tables 12[mysqld]skip-grant-tables :wq! #保存退出,重启MySQL服务 1service mysqld restart 进入MySQL控制台 1mysql -uroot -p #直接按回车，这时不需要输入root密码。 修改root密码 12345flush privileges; #刷新系统授权表 grant all on *.* to 'root'@'localhost' identified by 'newpassword' with grant option;flush privileges; 设置密码也可用1set password for 'root'@'localhost' = password(''); 如果哪一天忘记密码，执行以下命令更新密码 123456mysql&gt; UPDATE mysql.user SET authentication_string= password('root') WHERE User = 'root' ; Query OK, 1 row affected, 1 warning (0.01 sec)Rows matched: 1 Changed: 1 Warnings: 1mysql&gt; flush privileges;Query OK, 0 rows affected (0.01 sec) 并重启服务 1[root@localhost ~]# systemctl restart mysqld.service 取消/etc/my.cnf中的skip-grant-tables vi /etc/my.cnf 编辑文件，找到[mysqld]，删除skip-grant-tables这一行 配置文件和数据配置文件默认位置: Linux: /etc/my.cnfWindows: my.ini 在mysql安装的home目录 数据文件位置 命令：show variables like &#39;%datadir%&#39; ; 数据文件格式 InnoDB frm : 存储表结构 ibd：存储数据和索引 MyISAM frm： 存储表结构 MYD：存储数据 MYI：存储索引 字符集设置查看当前字符集 1mysql&gt; show variables like 'character%'; 输出结果如下： 123456789101112 +--------------------------+----------------------------+| Variable_name | Value |+--------------------------+----------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | utf8 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | utf8 || character_set_system | utf8 || character_sets_dir | /usr/share/mysql/charsets/ |+--------------------------+----------------------------+ 名词解释： character_set_client：客户端请求数据的字符集 character_set_connection：客户机/服务器连接的字符集 character_set_database：默认数据库的字符集，无论默认数据库如何改变，都是这个字符集；如果没有默认数据库，那就使用 character_set_server指定的字符集，这个变量建议由系统自己管理，不要人为定义。 character_set_filesystem：把os上文件名转化成此字符集，即把 character_set_client转换character_set_filesystem， 默认binary是不做任何转换的 character_set_results：结果集，返回给客户端的字符集 character_set_server：数据库服务器的默认字符集 character_set_system：系统字符集，这个值总是utf8，不需要设置。这个字符集用于数据库对象（如表和列）的名字，也用于存储在目录表中的函数的名字。 编辑/etc/my.cnf文件，添加如下字符集设置 1234567891011121314[client]#影响参数：character_set_client，character_set_connection和character_set_results。default-character-set=utf8[mysql]default-character-set=utf8[mysqld]#影响参数：character_set_server 和 character_set_databaseinit_connect='SET collation_connection = utf8_unicode_ci'init_connect='SET NAMES utf8'character-set-server=utf8collation-server=utf8_unicode_ciskip-character-set-client-handshake 修改之后重启数据库生效 1service mysqld restart #重启MySQL服务]]></content>
      <categories>
        <category>MySQL优化</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
